<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Лучшие практики swift (часть 1)  &middot; Developer&#39;s adventures</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="description" content="Перевод статьи Sam Dods о том, какие практики он использует при работе с языком Swift 2." />

<meta name="keywords" content="swift best practice, swift practice, лучшие практики swift, swift 2, ">


<meta property="og:title" content="Лучшие практики swift (часть 1)  &middot; Developer&#39;s adventures ">
<meta property="og:site_name" content="Developer&#39;s adventures"/>
<meta property="og:url" content="http://rag0n.github.io/2015/10/28/%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-swift-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1/" />
<meta property="og:locale" content="ru">


<meta property="og:type" content="article" />
<meta property="og:description" content="Перевод статьи Sam Dods о том, какие практики он использует при работе с языком Swift 2."/>
<meta property="og:article:published_time" content="2015-10-28T09:34:02&#43;03:00" />
<meta property="og:article:modified_time" content="2015-10-28T09:34:02&#43;03:00" />

  
    
<meta property="og:article:tag" content="swift best practice">
    
<meta property="og:article:tag" content="swift practice">
    
<meta property="og:article:tag" content="лучшие практики swift">
    
<meta property="og:article:tag" content="swift 2">
    
  

  

<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "Article",
    "headline": "Лучшие практики swift (часть 1)",
    "author": {
      "@type": "Person",
      "name": "http://profiles.google.com/+?rel=author"
    },
    "datePublished": "2015-10-28",
    "description": "Перевод статьи Sam Dods о том, какие практики он использует при работе с языком Swift 2.",
    "wordCount":  1242 
  }
</script>



<link rel="canonical" href="http://rag0n.github.io/2015/10/28/%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-swift-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1/" />

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://rag0n.github.io/touch-icon-144-precomposed.png">
<link href="http://rag0n.github.io/favicon.png" rel="icon">

<meta name="generator" content="Hugo 0.15" />

  <!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link href='https://fonts.googleapis.com/css?family=Merriweather:300%7CRaleway%7COpen+Sans' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="http://rag0n.github.io/css/font-awesome.min.css">
<link rel="stylesheet" href="http://rag0n.github.io/css/style.css">
<link rel="stylesheet" href="http://rag0n.github.io/css/highlight/solarized_dark.css">

  
</head>
<body>
  <main id="main-wrapper" class="container main_wrapper has-sidebar right">
    <header id="main-header" class="container main_header">
  <div class="container brand">
  <div class="container title h1-like">
  <a class="baselink" href="http://rag0n.github.io/">
  Alexander Guschin

</a>

</div>

  
<div class="container topline">
  
  Notes about my dev adventures


</div>


</div>

  <nav class="container nav primary no-print">
  

<a class="homelink" href="http://rag0n.github.io/">Blog</a>


  
<a href="http://rag0n.github.io/about" title="About me">About</a>

<a href="http://rag0n.github.io/tags" title="Show list of tags">Tags</a>


</nav>

<div class="container nav secondary no-print">
  
<a id="contact-link-email" class="contact_link" href="mailto:alexander.ragon@gmail.com">
  <span class="fa fa-envelope-square"></span><span>email</span></a>



<a id="contact-link-github" class="contact_link" href="https://github.com/Rag0n">
  <span class="fa fa-github-square"></span><span>github</span></a>



<a id="contact-link-bitbucket" class="contact_link" href="https://bitbucket.org/Rag0n">
  <span class="fa fa-bitbucket-square"></span><span>bitbucket</span></a>











<a id="contact-link-youtube" class="contact_link" href="https://www.youtube.com/channel/UC3lJRhdqaLohrPwVJdNCPbQ">
  <span class="fa fa-youtube-square"></span><span>youtube</span></a>





</div>


  

</header>


<article id="main-content" class="container main_content single">
  <header class="container hat">
  <h1>Лучшие практики swift (часть 1)
</h1>

  <div class="metas">
<time datetime="2015-10-28">28 Oct, 2015</time>


  
    &middot; by rag0n
  
  &middot; Read in about 6 min
  &middot; (1242 Words)
  <br>
  
<a class="label" href="http://rag0n.github.io/tags/%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4">перевод</a>

<a class="label" href="http://rag0n.github.io/tags/swift">swift</a>



</div>

</header>

  <div class="container content">
  

<p>Я начал изучать swift сразу же после анонса. За первые пару дней я прочитал The Swift Programming Language(Apple). Я писал небольшие приложения и одновременно игрался с новым языком, но никогда не чувствовал, что язык достаточно взрослый для больших проектов.</p>

<p>Но это было до анонса swift 2.0. После анонса я стал использовать swift все больше и больше и наконец недавно начал писать большой проект для <a href="http://www.theappbusiness.com/">The App Business</a> используя swift.</p>

<p>Я решил поделиться своими наблюдениями - некоторые из них очевидны и общеприняты, но, надеюсь, некоторые будут новыми для большинства читателей.</p>

<hr />

<h2 id="предпочитайте-let-вместо-var:60e2ba6dfcacc9c41dad457311fc4e49">Предпочитайте <code>let</code> вместо <code>var</code></h2>

<p>Тренируйте свой мозг и рефлексы по умолчанию использовать let. Вы можете объявить переменную как var наперед, но я рекомендую использовать var только если вам обязательно надо изменить значение переменной. Это самый очевидный пункт из моих лучших практик, но это очень важно и стоит упоминания.</p>

<p><strong><em>Примечание от переводчика:</em></strong> в xCode 7 компилятор автоматически анализирует, меняете ли вы значение у переменной, объявленной как <code>var</code> и предлагает изменить ее на <code>let</code> в противном случае.</p>

<h2 id="предпочитайте-приватный-private-контроль-доступа:60e2ba6dfcacc9c41dad457311fc4e49">Предпочитайте приватный(<code>private</code>) контроль доступа</h2>

<p>Опять очевидный пункт, но он также стоит упоминания. Всегда лучше скрывать как можно больше реализации(что означает доступ только из того же исходного файла).</p>

<h2 id="предпочитайте-не-опциональные-типы:60e2ba6dfcacc9c41dad457311fc4e49">Предпочитайте не опциональные типы</h2>

<p>Опциональные типы потрясающие. Этот концепт существует и в других языках(Scala, Haskell, и др).</p>

<p>Но несмотря на то, какими полезными они могут быть, я все же пытаюсь избегать их, если это возможно. Это приводит к более чистому коду, если вы знаете, что переменная или атрибут содержат значение, или что функция возвращает действительное(не nil) значение.</p>

<p>Например, я предпочитаю вызывать исключения в случаях, когда  функция не может вернуть действительное(не nil) значение. Посмотрите на <code>NSJSONSerialization.JSONObjectWithData</code>. Эта функция гарантирует, что она возвращает значение, иначе она вызывает исключение.</p>

<h2 id="предпочитайте-guard-let-вместо-if-let:60e2ba6dfcacc9c41dad457311fc4e49">Предпочитайте <code>guard let</code> вместо <code>if let</code></h2>

<p>Что вы можете сделать в <code>if let</code> блоке? Я почти всегда использую <code>guard let</code> и ранний возврат из функции, если что-то идет не так. Ранний возврат способствует более легкому чтению кода, т.к вы можете гарантировать корректное состояние переменных. Если вы не можете вычислить обязательное значение, используйте ранний возврат(return).</p>

<h2 id="не-бойтесь-вызывать-исключения:60e2ba6dfcacc9c41dad457311fc4e49">Не бойтесь вызывать исключения</h2>

<p>Вместо раннего возврата, вы можете вызвать исключение, как альтернативную точку выхода из функции. Обработка исключений в Objective-C (<code>@try @catch</code>) всегда была доступна, хотя использовать эту возможность было не принято. В Swift обработка исключений является фундаментальной идеей и вы должны использовать это.</p>

<p>Например, у меня была функция парсинга, которая возвращала опциональный тип, если данные не могли быть синтаксически разобраны. Это означает, что вызывающая программа должна была проверять возвращаемое значение на <code>nil</code>. Я отрефакторил эту функцию так, чтобы она всегда возвращала действительное значение и вызывала исключение в противном случае.</p>

<h2 id="не-используйте-guard-для-многочисленных-проверок:60e2ba6dfcacc9c41dad457311fc4e49">Не используйте <code>guard</code> для многочисленных проверок</h2>

<p>Рассмотрим код:</p>

<pre><code class="language-objectivec">guard let data = data,
          son = self.jsonFromData(data),
          authors = json[&quot;authors&quot;] else {
  throw AuthorParserError
}
</code></pre>

<p>В нем избегаются повторные вызовы исключения <code>AuthorParserError</code>, но по моему мнению было бы намного лучше написать так:</p>

<pre><code class="language-objectivec">guard let data = data else {
  throw AuthorParserError
}
guard let son = self.jsonFromData(data) else {
  throw AuthorParserError
}
guard let authors = json[&quot;authors&quot;] else {
  throw AuthorParserError
}
</code></pre>

<p>В данном варианте можно протестировать каждый случай по отдельности и вы можете быть уверены, что вы проверили все случаи, иначе Xcode покажет ошибку на неразвернутых опциональных типах.</p>

<h2 id="всегда-вносите-зависимости-даже-если-они-предназначены-только-для-тестирования:60e2ba6dfcacc9c41dad457311fc4e49">Всегда вносите зависимости, даже если они предназначены только для тестирования</h2>

<p>В swift есть удобная возможность - необязательные аргументы функций. С одной стороны вы можете указывать как использовать функцию по умолчанию, с другой - облегчить тестирование классов,  в частности зависимости мок-объектов.</p>

<p>Например, если ваш класс рассчитывает, что кто-либо будет обрабатывать сетевые запросы, то почему бы не передать мок-объект в инициализатор класса?</p>

<p>Это облегчит тестирование, т.к вы можете создать мок-объект для зависимостей и протестировать функциональность одного конкретного класса(Конечно, вы также можете написать более интегрированные тесты).</p>

<p>Например:</p>

<pre><code class="language-objectivec">public init(requestDelegate: MyClassRequestDelegate = RequestManager()) {
  self.requestDelegate = requestDelegate
}
</code></pre>

<p>В коде выше зависимость - это на самом деле протокол, который облегчает тестирование, т.к нам достаточно создать мок-объект, который удовлетворяет этому протоколу.</p>

<p>Некоторые программисты могут внести зависимость навсегда, вместо определения значения по умолчанию. Но мне кажется, что главная задача для этого типа зависимостей - облегчить тестирование. Если вы не пишите библиотеку, ваше приложение вероятно всегда использует одну и ту же зависимость, поэтому есть смысл определить ее как зависимость по умолчанию.</p>

<h2 id="всегда-используйте-псевдонимы-типа-typealias-для-завершающих-обработчиков-если-это-возможно:60e2ba6dfcacc9c41dad457311fc4e49">Всегда используйте псевдонимы типа(<code>typealias</code>) для завершающих обработчиков(если это возможно)</h2>

<p>Несмотря на то, что синтаксис замыканий может быть <a href="http://fuckingclosuresyntax.com/">запутывающим</a>,  синтаксис для псевдонима замыкания очевидно проще, чем эквивалентный <code>typedef</code> в Objective-C. Поэтому всегда объявляйте псевдоним для завершающих обработчиков(конечно если они не содержат обобщенных типов).</p>

<pre><code class="language-objectivec">typealias SomethingCompletion = (result: SomeType) -&gt; Void
</code></pre>

<h2 id="используйте-перечисления-enum-для-уменьшения-неопределенности:60e2ba6dfcacc9c41dad457311fc4e49">Используйте перечисления(<code>enum</code>) для уменьшения неопределенности</h2>

<p>В этом фрагменте кода я передаю завершающему обработчику кортеж, который повышает неопределенность.</p>

<pre><code class="language-objectivec">doSomething() { (output: NSData?, error: NSError?) in
  // need to check if we have output or error
}
</code></pre>

<blockquote>
<p>Заметьте, что я использую <code>NSError</code> вместо вызова исключения, т.к невозможно вызывать исключения асинхронно.</p>
</blockquote>

<p>Кортеж принимает 2 опциональных значения, что также противоречит тому, о чем о писал выше(используйте не опциональные типы).</p>

<p>Что будет, если мы не передадим ни <code>output</code>, ни <code>error</code>? Что если мы передадим значения вовсе?</p>

<p>Вы должны явно передавать аргументы в обработчик и в этом вам могут помочь перечисления. Например, вы могли бы определить перечисление <code>Result</code>:</p>

<pre><code class="language-objectivec">enum Result&lt;U&gt; {
  case .Success(output: U)
  case .Failure(error: NSError)
}
</code></pre>

<p>Теперь можно переписать обработчик ошибок так:</p>

<pre><code class="language-objectivec">doSomething() { result in
  switch (result) {
  case .Success(let output):
    // use output
  case .Failure(let error):
    // handle error
  }
}
</code></pre>

<p>Теперь стало абсолютно ясно, что если вызов функции был успешен, мы получим действительный результат(и мы даже будем знать его тип). И наоборот, если вызов неуспешен мы получим ошибку. Результат может быть либо успешным, либо не успешным. Без неопределенности.</p>

<h2 id="трюк-для-обобщенного-завершающего-обработчика:60e2ba6dfcacc9c41dad457311fc4e49">Трюк для обобщенного завершающего обработчика</h2>

<p>Предположим у вас есть функция, объявленная в протоколе:</p>

<pre><code class="language-objectivec">protocol ServiceProvider {
  func provideService&lt;U where U: AnyService&gt;(completion: (output: U) -&gt; Void)
}
</code></pre>

<p>При объявлении класса,
Если при объявлении класса, соответствующего протоколу(т.е реализация методов протокола) вы знаете как создать экземпляр объекта типа <code>U whee U: AnyService</code>, тогда вы можете вернуть объект соответствующего типа(<code>AnyService</code> протокол должен предоставлять способ создания/возвращения экземпляра).</p>

<p>В этом случае вызывающий объект определяет какой объект должен быть возвращен в замыкании.</p>

<p>Например:</p>

<pre><code class="language-objectivec">myOtherClass.provideService { (output: RoomService) in
  // do something with the RoomService
}
</code></pre>

<p>Реализация <code>provideService</code> ничего не знает о классе <code>RoomService</code>. Этот класс просто удовлетворяет протоколу <code>AnyService</code> благодаря чему можно создать его экземпляры в замыкании.</p>

<p>Мне особенно нравится идея, что вызывающий может получить обратно именно тот объект, который он хочет. Вызывающий объект просто говорит: &laquo;В завершающем обработчике я хочу получить экземпляр <code>RoomService</code> и реализованная функция знает, как это сделать&raquo;.</p>

<p>Это полная противоположность блокам в <code>Objective C</code>, где мы должны были бы объявить аргумент завершающего обработчика с типом <code>id</code> и вызывающий объект сказал бы компилятору какой тип объекта он ожидает получить назад при реализации завершающего обработчика.</p>

<h2 id="лучшие-практики-замыканий:60e2ba6dfcacc9c41dad457311fc4e49">Лучшие практики замыканий</h2>

<p>Я пытаюсь сохранять замыкания как можно более краткими и лаконичными.</p>

<ul>
<li>Если замыкание возвращает <code>Void</code>, не пишите возращаемое значение</li>
<li>Если тип объекта может быть выведен компилятором, не указывайте его тип</li>
<li>Если замыкание имеет только один аргумент, не помещайте его в скобки</li>
<li>Всегда передавайте замыкание как последний аргумент</li>
<li>Всегда используйте trail(хвостовой) синтакс для замыкания, передающихся как последний аргумент</li>
<li>Не используйте скобки, если компилятор того не требует(например, если функция имеет один аргумент и этот аргумент - замыкание)</li>
</ul>

<p>Все эти утверждения спорные, но сейчас я имеено так использую замыкания. Например:</p>

<pre><code class="language-objectivec">myObject.doSomething { output in
  // do something with the output
}
</code></pre>

<p>вместо:</p>

<pre><code class="language-objectivec">myObject.doSomething() { (output: NSData?) -&gt; Void in
  // do something with the output
}
</code></pre>

<h4 id="p-s:60e2ba6dfcacc9c41dad457311fc4e49">P.S</h4>

<p>Я знаю, что перевод ужасен, именно поэтому я и сделал его(несмотря на то, что в статье используется простой англиский). Но невозможно улучшить какой-либо навык, ничего не делая. The growth mindset и все такое.</p>

<p>Ссылка на <a href="http://sam.dods.co/blog/2015/09/21/some-swift-best-practices/">оригинал</a></p>

</div>


  <footer class="container">
  <div class="container navigation no-print">
  <h2>Navigation</h2>
  
  

    
    <a class="prev" href="http://rag0n.github.io/2015/10/24/%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-autolayout-constraints/" title="Как программно добавить Autolayout constraints">
      Previous
    </a>
    

    
    <a class="next" href="http://rag0n.github.io/2015/12/01/swift-design-patterns-strategy/" title="Swift Design Patterns: Strategy">
      Next
    </a>
    

  


</div>

  <div class="container comments">
  <h2>Comments</h2>
  
<div id="disqus_thread"></div>
<script type="text/javascript">
  (function() {
    
    
    if (window.location.hostname == "localhost")
      return;

    var dsq = document.createElement('script'); dsq.async = true; dsq.type = 'text/javascript';
    dsq.src = '//rag0n.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


</div>

</footer>

</article>
      <footer id="main-footer" class="container main_footer">
  

  <div class="container nav foot no-print">
  

  <a class="toplink" href="#">back to top</a>

</div>

  <div class="container credits">
  
<div class="container footline">
  
  <i class='fa fa-code'></i> Keep calm and carry on coding


</div>


  
<div class="container copyright">
  
  &copy; 2015 Rag0n


</div>


</div>

</footer>

    </main>
    
<script type="text/javascript">
  (function() {
    
    
    if (window.location.hostname == "localhost")
      return;

    var dsq = document.createElement('script'); dsq.async = true; dsq.type = 'text/javascript';
    dsq.src = '//rag0n.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



<script src="http://rag0n.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71035774-1', 'auto');
  ga('send', 'pageview');

</script>


    
  </body>
</html>

