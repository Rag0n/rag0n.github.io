<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Developer&#39;s adventures</title>
    <link>http://rag0n.github.io/post/</link>
    <description>Recent content in Posts on Developer&#39;s adventures</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <managingEditor>alexander.ragon@gmail.com (Alexander Guschin)</managingEditor>
    <webMaster>alexander.ragon@gmail.com (Alexander Guschin)</webMaster>
    <copyright>(c) 2015 Rag0n</copyright>
    <lastBuildDate>Fri, 18 Dec 2015 14:04:01 +0300</lastBuildDate>
    <atom:link href="http://rag0n.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Swift Design Patterns: Singleton</title>
      <link>http://rag0n.github.io/2015/12/18/swift-design-patterns-singleton/</link>
      <pubDate>Fri, 18 Dec 2015 14:04:01 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/18/swift-design-patterns-singleton/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Singleton применяется, если в приложении должен использоваться один и только один экземпляр класса. Кроме того, желательно иметь ленивую инициализацию и глобальный доступ.&lt;/p&gt;

&lt;h3 id=&#34;определение&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация&#34;&gt;Реализация&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Объявите статичный аттрибут-константу в классе&lt;/li&gt;
&lt;li&gt;Используйте приватный метод доступа у инициализатора&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;Реализация на языке Swift получается в одну строчку. Связано это с тем, что для глобальных и статичных переменных структур, перечислений и классов используется ленивая инициализация. Ленивая инициализация запускается единожды и является потокобезопасной(атомарной), т.к используется &lt;code&gt;dispatch_once&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class SomeClass {
    static let sharedInstance = SomeClass()
    private init() { }
    
    // другие методы
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;реализация-паттерна-singleton&#34;&gt;Реализация паттерна Singleton:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/Singleton.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-singleton&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Design Patterns: Command</title>
      <link>http://rag0n.github.io/2015/12/18/swift-design-patterns-command/</link>
      <pubDate>Fri, 18 Dec 2015 14:00:39 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/18/swift-design-patterns-command/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен:18f42655bc34c316ea561fdfae1d14c2&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Command применяется, когда необходимо выполнять команды(операции, запросы), без знания того, какие функции должны вызываться и даже того, кто должен выполнять эти функции. Паттерн инкапсулирует вычислительные блоки(получателя + набор операций). Его можно применять в планировщиках, различных пулах, очередях задач.&lt;/p&gt;

&lt;p&gt;Обеспечивает соблюдение принципа инверсии зависимостей. Уменьшает связанность классов.&lt;/p&gt;

&lt;h3 id=&#34;определение:18f42655bc34c316ea561fdfae1d14c2&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;инкапсулирует запрос в виде объекта, делая возможной параметризацию клиентских объектов с различными запросами, организацию очереди или регистрацию запросов, а также поддержку отмены операций&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация:18f42655bc34c316ea561fdfae1d14c2&#34;&gt;Реализация&lt;/h3&gt;

&lt;p&gt;Command разъединяет(decouple) объект, который вызывает операцию от объекта, который знает как эту операцию выполнить. Для этого создается интерфейс Command, который связывает получателя с действием. Интерфейс содержит абстрактный метод &lt;code&gt;execute&lt;/code&gt;, который вызывает действия у получателя. Клиенты Command рассматривают получателя как черную коробку: когда необходимо, клиент вызывает метод &lt;code&gt;execute&lt;/code&gt; и больше его ничего не волнует.&lt;/p&gt;

&lt;p&gt;Клиент, создающий команду и клиент, выполняющий команду - разные клиенты. Данное разделение обеспечивает гибкость во времени выполнения и последовательности команд. Инкапсуляция команд в виде объекто делает возможным их передачу/хранение/загрузку и тд.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Определите интерфейс команды с сигнатурой метода такой как &lt;code&gt;execute()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Создайте несколько конкретных классов комманд, содержащих объект получателя, методы, которые нужно вызвать и аргументы, которые нужно передать получателю.&lt;/li&gt;
&lt;li&gt;Инициализируйте объекты команд для каждого отложенного выполнения&lt;/li&gt;
&lt;li&gt;Передайте объекты команд от создателя(отправителя, sender) к инициатору(invoker)&lt;/li&gt;
&lt;li&gt;Инициатор определяет, когда выполнять команды&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример:18f42655bc34c316ea561fdfae1d14c2&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;Допустим у нас есть пульт управления умным домом. В нем есть возможность задать несколько устройств, и для каждого устройства есть кнопка on и off.&lt;/p&gt;

&lt;p&gt;Определим интерфейс команды&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактная команда, используем для инкапсуляции классов устройств(устройство + операции)
// в результате при добавлении новых классов устройств
// не нужно будет изменять управляющий класс пульта(remoteControl)
protocol Command {
    func execute()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создадим несколько конкретных классов команд&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// классы конкретных комманд, инкапсулируют запросы к конкретным устройствам
class NoCommand: Command {
    // объект-получатель
    func execute() {
        print(&amp;quot;No command&amp;quot;)
    }
}

class LightOnCommand: Command {
    // объект-получатель
    private let light: Light
    
    init(light: Light) {
        self.light = light
    }
    
    func execute() {
        // методы, которые нужно вызвать, без аргументов
        light.on()
    }
}

class LightOffCommand: Command {
    // объект-получатель
    private let light: Light
    
    init(light: Light) {
        self.light = light
    }
    
    func execute() {
        // методы, которые нужно вызвать, без аргументов
        light.off()
    }
}

class StereoOnWithCDCommand: Command {
    // объект-получатель
    private let stereo: Stereo
    
    init(stereo: Stereo) {
        self.stereo = stereo
    }
    
    func execute() {
        // методы, которые нужно вызвать, без аргументов
        stereo.on()
        stereo.setCD()
        stereo.setVolume()
    }
}

class GarageOpenCommand: Command {
    // объект-получатель
    private let garage: Garage
    
    init(garageDoor: Garage) {
        self.garage = garageDoor
    }
    
    func execute() {
        // методы, которые нужно вызвать, без аргументов
        garage.openDoor()
    }
}

class GarageCloseCommand: Command {
    // объект-получатель
    private let garage: Garage
    
    init(garageDoor: Garage) {
        self.garage = garageDoor
    }
    
    func execute() {
        // методы, которые нужно вызвать, без аргументов
        garage.closeDoor()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Инициализируем объекты команд&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;let livingRoomLight = Light(site: &amp;quot;Living Room&amp;quot;)
let livingRoomLightOn = LightOnCommand(light: livingRoomLight)
let livingRoomLightOff = LightOffCommand(light: livingRoomLight)

let kitchenLight = Light(site: &amp;quot;Kitchen&amp;quot;)
let kitchenLightOn = LightOnCommand(light: kitchenLight)
let kitchenLightOff = LightOffCommand(light: kitchenLight)

let garage = Garage()
let garageOpen = GarageOpenCommand(garageDoor: garage)
let garageClose = GarageCloseCommand(garageDoor: garage)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Передадим объекты команд от создателя(creator) к инициатору(invoker)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;let remote = RemoteControl()
remote.setCommand(0, onCommand: livingRoomLightOn, offCommand: livingRoomLightOff)
remote.setCommand(1, onCommand: kitchenLightOn, offCommand: kitchenLightOff)
remote.setCommand(2, onCommand: garageOpen, offCommand: garageClose)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В нашем случае команды выполняются по нажатию кнопок на пульте управления&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;remote.onButtonPressed(0)
remote.offButtonPressed(0)
remote.undoButtonPressed()

remote.onButtonPressed(1)
remote.offButtonPressed(1)

remote.onButtonPressed(2)
remote.offButtonPressed(2)

remote.onButtonPressed(3)
remote.offButtonPressed(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В качестве другого примера можно рассмотреть ресторан. Командой в данном случае будет заказ. Посетитель - клиент-создатель(client, creator), официантка - инициатор, повар - получатель.&lt;/p&gt;

&lt;h4 id=&#34;реализация-паттерна-command:18f42655bc34c316ea561fdfae1d14c2&#34;&gt;Реализация паттерна Command:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/Command.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-command&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Design Patterns: Abstract Factory</title>
      <link>http://rag0n.github.io/2015/12/17/swift-design-patterns-abstract-factory/</link>
      <pubDate>Thu, 17 Dec 2015 10:18:13 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/17/swift-design-patterns-abstract-factory/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Abstract factory применяется для инкапсуляции зависимостей(операционная система, базы данных и тд). Клиент используют интерфейс, предоставляемый фабрикой, а конкретная реализация(конкретная фабрика) определяется на этапе исполнения.&lt;/p&gt;

&lt;p&gt;Обеспечивает соблюдение принципа инверсии зависимостей. Уменьшает связанность классов.&lt;/p&gt;

&lt;h3 id=&#34;определение&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;предоставляет интерфейс создания семейства взаимосвязанных или взаимозависимых объектов без указания их конкретных классов&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация&#34;&gt;Реализация&lt;/h3&gt;

&lt;p&gt;Объект фабрики берет на себя ответственность за создание сервисов для всего семейства продуктов. Клиенты не создают объекты напрямую, а делегируют создание фабрике. Таким образом, для создания объектов используется композиция.&lt;/p&gt;

&lt;p&gt;Реализация использует фабричный метод для каждого продукта. Каждый фабричный метод инкапсулирует &lt;code&gt;new&lt;/code&gt; оператор и конкретные, платформо-зависимые классы.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Спроектируйте интерфейс семеств продуктов, для каждого объекта свой фабричный метод&lt;/li&gt;
&lt;li&gt;Определите конкретную фабрику для каждого семейства зависимых продуктов&lt;/li&gt;
&lt;li&gt;Клиент должен использовать фабричные методы конкретной фабрики для создания продуктов, конкретную фабрику получает через инициализатор(используется делегация)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;Допустим у нас есть сеть пиццерий по всей стране. В Нью-Йорке жители любят тонкий слой теста, одни специи. В Чикаго - толстый слой теста, другие специи.&lt;/p&gt;

&lt;p&gt;Мы хотим стандартизировать ингредиенты с учетом того, что в разных регионах могут использоваться разные соусы и тд. Таким образом наименование ингредиентов остается одинаковым, а реализация - разной.&lt;/p&gt;

&lt;p&gt;Для этого объявим общий интерфейс семейств продуктов(набор фабричных методов):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактная фабрика
protocol PizzaIngredientFactory {
    func createDough() -&amp;gt; Dough
    func createSauce() -&amp;gt; Sauce
    func createCheese() -&amp;gt; Cheese
    func createVeggies() -&amp;gt; [Veggies]
    func createPepperoni() -&amp;gt; Pepperoni
    func createClam() -&amp;gt; Clams
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;И реализуем конкретные фабрики. Обратите внимание, что реализация ингредиентов отличается.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретная фабрика
class NYPizzaIngredientFactory: PizzaIngredientFactory {
    func createDough() -&amp;gt; Dough {
        return ThinCrustDough()
    }
    
    func createSauce() -&amp;gt; Sauce {
        return MarinaraSauce()
    }
    
    func createCheese() -&amp;gt; Cheese {
        return ReggianoCheese()
    }
    
    func createVeggies() -&amp;gt; [Veggies] {
        let veggies: [Veggies] = [Garlic(), Onion(), Mushroom(), RedPepper()]
        return veggies
    }
    
    func createPepperoni() -&amp;gt; Pepperoni {
        return SlicedPepperoni()
    }
    
    func createClam() -&amp;gt; Clams {
        return FreshClams()
    }
}

// конкретная фабрика
class ChikagoPizzaIngredientFactory: PizzaIngredientFactory {
    func createDough() -&amp;gt; Dough {
        return ThinCrustDough()
    }
    
    func createSauce() -&amp;gt; Sauce {
        return MarinaraSauce()
    }
    
    func createCheese() -&amp;gt; Cheese {
        return ReggianoCheese()
    }
    
    func createVeggies() -&amp;gt; [Veggies] {
        let veggies: [Veggies] = [Garlic(), Onion(), Mushroom(), RedPepper()]
        return veggies
    }
    
    func createPepperoni() -&amp;gt; Pepperoni {
        return SlicedPepperoni()
    }
    
    func createClam() -&amp;gt; Clams {
        return FreshClams()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Определим абстрактного клиента&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактные продукт
protocol Pizza {
    var name: String! { get set }
    var dough: Dough! { get }
    var sauce: Sauce! { get }
    var veggies: [Veggies]? { get }
    var cheese: Cheese? { get }
    var pepperoni: Pepperoni? { get }
    var clam: Clams? { get }
    
    // абстрактный метод
    func prepare()
    
    func bake()
    func cut()
    func box()
}

extension Pizza {
    
    func bake() {
        print(&amp;quot;Bake for 25 minutes at 350&amp;quot;)
    }
    
    func cut() {
        print(&amp;quot;Cutting the pizza into diagonal slices&amp;quot;)
    }
    
    func box() {
        print(&amp;quot;Place pizza in official PizzaStore box&amp;quot;)
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Реализуем конкретных клиентов. Конкретную фабрику получаем через инициализатор, реализацию &lt;code&gt;prepare&lt;/code&gt; делегируем фабрике&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретный продукт
class CheesePizza: Pizza {
    var name: String!
    var dough: Dough!
    var sauce: Sauce!
    var veggies: [Veggies]?
    var cheese: Cheese?
    var pepperoni: Pepperoni?
    var clam: Clams?
    
    var ingredientFactory: PizzaIngredientFactory
    
    init(ingredientFactory: PizzaIngredientFactory) {
        self.ingredientFactory = ingredientFactory
    }
    
    func prepare() {
        print(&amp;quot;Preparing \(name)&amp;quot;)
        dough = ingredientFactory.createDough()
        sauce = ingredientFactory.createSauce()
        cheese = ingredientFactory.createCheese()
    }
}

// конкретный продукт с другими ингредиентами
class ClamPizza: Pizza {
    var name: String!
    var dough: Dough!
    var sauce: Sauce!
    var veggies: [Veggies]?
    var cheese: Cheese?
    var pepperoni: Pepperoni?
    var clam: Clams?
    
    var ingredientFactory: PizzaIngredientFactory
    
    init(ingredientFactory: PizzaIngredientFactory) {
        self.ingredientFactory = ingredientFactory
    }
    
    func prepare() {
        print(&amp;quot;Preparing \(name)&amp;quot;)
        dough = ingredientFactory.createDough()
        sauce = ingredientFactory.createSauce()
        cheese = ingredientFactory.createCheese()
        // У Нью-Йоркской фабрики мидии будут свежими, у Чикагской - мороженными
        // но наши классы от этого не зависят - данные аспекты определяются фабрикой
        clam = ingredientFactory.createClam()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создадим экземпляр конкреткой фабрики и будем передавать его клиентам&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактный класс создатель
protocol PizzaStore {
    func orderPizza(type: String) -&amp;gt; Pizza
    // фабричный метод
    func createPizza(type: String) -&amp;gt; Pizza
}

extension PizzaStore {
    func orderPizza(type: String) -&amp;gt; Pizza {
        // для создание пиццы используем фабричный метод
        let pizza = createPizza(type)
        
        pizza.prepare()
        pizza.bake()
        pizza.cut()
        pizza.box()
        
        return pizza
    }
}

// конкретный класс-создатель
class NYPizzaStore: PizzaStore {
    
    func createPizza(type: String) -&amp;gt; Pizza {
        let ingredientFactory = NYPizzaIngredientFactory()
        let newPizza: Pizza
        
        switch type {
        case &amp;quot;cheese&amp;quot;:
            newPizza = CheesePizza(ingredientFactory: ingredientFactory)
            newPizza.name = &amp;quot;New York Style Cheese Pizza&amp;quot;
        case &amp;quot;clam&amp;quot;:
            newPizza = ClamPizza(ingredientFactory: ingredientFactory)
            newPizza.name = &amp;quot;New York Style Clam Pizza&amp;quot;
        default:
            newPizza = CheesePizza(ingredientFactory: ingredientFactory)
            newPizza.name = &amp;quot;New York Style Cheese Pizza&amp;quot;
        }
        
        return newPizza
    }
}


// конкретный класс-создатель
class ChikagoPizzaStore: PizzaStore {
    // fabric method
    func createPizza(type: String) -&amp;gt; Pizza {
        let ingredientFactory: PizzaIngredientFactory = ChikagoPizzaIngredientFactory()
        let newPizza: Pizza
        
        switch type {
        case &amp;quot;cheese&amp;quot;:
            newPizza = CheesePizza(ingredientFactory: ingredientFactory)
            newPizza.name = &amp;quot;Chikago Style Cheese Pizza&amp;quot;
        case &amp;quot;clam&amp;quot;:
            newPizza = ClamPizza(ingredientFactory: ingredientFactory)
            newPizza.name = &amp;quot;Chikago Style Clam Pizza&amp;quot;
        default:
            newPizza = CheesePizza(ingredientFactory: ingredientFactory)
            newPizza.name = &amp;quot;Chikago Style Cheese Pizza&amp;quot;
        }
        return newPizza
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;let nyStore = NYPizzaStore()
let chikagoStore = ChikagoPizzaStore()
var pizza: Pizza
pizza = nyStore.orderPizza(&amp;quot;cheese&amp;quot;)
print(pizza.name)

\*
Preparing New York Style Cheese Pizza
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in official PizzaStore box
New York Style Cheese Pizza
*\

print(&amp;quot;\n&amp;quot;)
pizza = chikagoStore.orderPizza(&amp;quot;cheese&amp;quot;)
print(pizza.name)

\*
Preparing Chikago Style Cheese Pizza
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in official PizzaStore box
Chikago Style Cheese Pizza
*\
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;реализация-паттерна-abstract-factory&#34;&gt;Реализация паттерна Abstract Factory:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/FactoryAbstract.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-abstract-factory&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Design Patterns: Factory Method</title>
      <link>http://rag0n.github.io/2015/12/16/swift-design-patterns-factory-method/</link>
      <pubDate>Wed, 16 Dec 2015 17:15:56 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/16/swift-design-patterns-factory-method/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен:2473779ea5617c0f0f76721eb7a89d68&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Factory method применяется когда создатель(фреймворк) должен стандартизировать архитектурную модель для клиентов и одновременно позволить клиентам определять свои объекты предметной области(domain objets).&lt;/p&gt;

&lt;p&gt;Обеспечивает соблюдение принципа инверсии зависимостей. Уменьшает связанность классов.&lt;/p&gt;

&lt;h3 id=&#34;определение:2473779ea5617c0f0f76721eb7a89d68&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;определяет интерфейс создания объекта, но позволяет субклассам выбрать класс создаваемого экземпляра. Таким образом, Фабричный метод делегирует операцию создания экземпляра субклассам.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация:2473779ea5617c0f0f76721eb7a89d68&#34;&gt;Реализация&lt;/h3&gt;

&lt;p&gt;Суперкласс определяет стандартное поведение и делегирует детали создания субклассам, определенным пользователем. Для создания объектов используется наследование.&lt;/p&gt;

&lt;p&gt;Существует несколько реализаций:
статичный метод(вместо метода инициализации) или
абстрактный метод(реализация определяется подклассами)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Спроектируйте аргументы фабричного метода(по каким харектиристикам фабричный метод будет выбирать конкретный продукт)&lt;/li&gt;
&lt;li&gt;Объявите констуктуры приватными или защищенными&lt;/li&gt;
&lt;li&gt;Рассмотрите возможность создания внутреннего &amp;laquo;object pool&amp;raquo;, который позволит возвращать один и тот же экземпляр, вместо создания нового каждый раз&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример:2473779ea5617c0f0f76721eb7a89d68&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;Фабричный метод похож на абстрактную фабрику, но в нем отсутствует акцент на семействах.&lt;/p&gt;

&lt;p&gt;Допустим у нас есть сеть пиццерий по всей стране. В Нью-Йорке жители любят тонкий слой теста, немного специй. В Чикаго - толстый слой теста, много сыра.&lt;/p&gt;

&lt;p&gt;Мы хотим, чтобы процесс приготовления был стандартизирован и одинаков во всех пиццерий, но при этом учитывались особенности местной кухни.&lt;/p&gt;

&lt;p&gt;Для этого объявим общий интерфейс для пиццерий, при этом делегируем реализацию фабричного метода субклассам:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактный класс создатель
protocol PizzaStore {
    func orderPizza(type: String) -&amp;gt; Pizza
    // фабричный метод
    func createPizza(type: String) -&amp;gt; Pizza
}

extension PizzaStore {
    func orderPizza(type: String) -&amp;gt; Pizza {
        // для создание пиццы используем фабричный метод
        let pizza = createPizza(type)
        
        pizza.prepare()
        pizza.bake()
        pizza.cut()
        pizza.box()
        
        return pizza
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Объявим конкретные пиццерии, учитывающие местные обычаи - для этого реализуем фабричный метод&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретный класс-создатель
class NYPizzaStore: PizzaStore {
    
    func createPizza(type: String) -&amp;gt; Pizza {
        switch type {
            case &amp;quot;cheese&amp;quot;:
                return NYStyleCheesePizza()
            case &amp;quot;veggie&amp;quot;:
                return NYStyleVeggiePizza()
            case &amp;quot;clam&amp;quot;:
                return NYStyleClamPizza()
            case &amp;quot;pepperoni&amp;quot;:
                return NYStylePepperoniPizza()
        default:
            return NYStyleCheesePizza()
        }
    }
}


// конкретный класс-создатель
class ChikagoPizzaStore: PizzaStore {
    
    func createPizza(type: String) -&amp;gt; Pizza {
        switch type {
        case &amp;quot;cheese&amp;quot;:
            return ChikagoStyleCheesePizza()
        case &amp;quot;veggie&amp;quot;:
            return ChikagoStyleVeggiePizza()
        case &amp;quot;clam&amp;quot;:
            return ChikagoStyleClamPizza()
        case &amp;quot;pepperoni&amp;quot;:
            return ChikagoStylePepperoniPizza()
        default:
            return ChikagoStyleCheesePizza()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Объявим абстрактный продукт и стандартизируем процесс приготовления&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактный продукт
protocol Pizza {
    var name: String { get }
    var dough: String { get }
    var sauce: String { get }
    var toppings: [String] { get }
    
    func prepare()
    
    func bake()
    
    func cut()
    
    func box()
}

// добавляем реализацию по умолчанию
extension Pizza {
    
    func prepare() {
        print(&amp;quot;Preparing \(name)&amp;quot;)
        print(&amp;quot;Tossing dough...&amp;quot;)
        print(&amp;quot;Adding sauce&amp;quot;)
        print(&amp;quot;Adding toppings \(toppings)&amp;quot;)
    }
    
    func bake() {
        print(&amp;quot;Bake for 25 minutes at 350&amp;quot;)
    }
    
    func cut() {
        print(&amp;quot;Cutting the pizza into diagonal slices&amp;quot;)
    }
    
    func box() {
        print(&amp;quot;Place pizza in the official PizzaStore box&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создадим конкретные продукты&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретные продукты
class NYStyleCheesePizza: Pizza {
    let name = &amp;quot;Ny style Sauce and Cheese Pizza&amp;quot;
    let dough = &amp;quot;Thin Crust Dough&amp;quot;
    let sauce = &amp;quot;Marinara Sauce&amp;quot;
    let toppings = [&amp;quot;Grated Reggiano Cheese&amp;quot;]
}

class NYStyleVeggiePizza: Pizza {
    let name = &amp;quot;Ny style Sauce and Veggie Pizza&amp;quot;
    let dough = &amp;quot;Thin Crust Dough&amp;quot;
    let sauce = &amp;quot;Marinara Sauce&amp;quot;
    let toppings = [&amp;quot;Veggie&amp;quot;]
}

class NYStyleClamPizza: Pizza {
    let name = &amp;quot;Ny style Sauce and Clam Pizza&amp;quot;
    let dough = &amp;quot;Thin Crust Dough&amp;quot;
    let sauce = &amp;quot;Marinara Sauce&amp;quot;
    let toppings = [&amp;quot;Clam&amp;quot;]
}

class NYStylePepperoniPizza: Pizza {
    let name = &amp;quot;Ny style Sauce and Pepperoni Pizza&amp;quot;
    let dough = &amp;quot;Thin Crust Dough&amp;quot;
    let sauce = &amp;quot;Marinara Sauce&amp;quot;
    let toppings = [&amp;quot;Pepperoni&amp;quot;]
}

class ChikagoStyleCheesePizza: Pizza {
    let name = &amp;quot;Chikago style Deep Dish Cheese Pizza&amp;quot;
    let dough = &amp;quot;Extra Thick Crust Dough&amp;quot;
    let sauce = &amp;quot;Plum Tomato Sauce&amp;quot;
    let toppings = [&amp;quot;Shredded Mozarella Cheese&amp;quot;]
    
    func cut() {
        print(&amp;quot;Cutting pizza into square slices&amp;quot;)
    }
}

class ChikagoStyleVeggiePizza: Pizza {
    let name = &amp;quot;Chikago style Deep Dish Veggie Pizza&amp;quot;
    let dough = &amp;quot;Extra Thick Crust Dough&amp;quot;
    let sauce = &amp;quot;Plum Tomato Sauce&amp;quot;
    let toppings = [&amp;quot;Veggie&amp;quot;]
    
    func cut() {
        print(&amp;quot;Cutting pizza into square slices&amp;quot;)
    }
}

class ChikagoStyleClamPizza: Pizza {
    let name = &amp;quot;Chikago style Deep Dish Clam Pizza&amp;quot;
    let dough = &amp;quot;Extra Thick Crust Dough&amp;quot;
    let sauce = &amp;quot;Plum Tomato Sauce&amp;quot;
    let toppings = [&amp;quot;Clam&amp;quot;]
    
    func cut() {
        print(&amp;quot;Cutting pizza into square slices&amp;quot;)
    }
}

class ChikagoStylePepperoniPizza: Pizza {
    let name = &amp;quot;Chikago style Deep Dish Pepperoni Pizza&amp;quot;
    let dough = &amp;quot;Extra Thick Crust Dough&amp;quot;
    let sauce = &amp;quot;Plum Tomato Sauce&amp;quot;
    let toppings = [&amp;quot;Pepperoni&amp;quot;]
    
    func cut() {
        print(&amp;quot;Cutting pizza into square slices&amp;quot;)
    }
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Посетим пиццерию в Нью-Йорке и закажем сырную пиццу&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;let nyStore = NYPizzaStore()
let NYPizza = nyStore.orderPizza(&amp;quot;cheese&amp;quot;)
print(NYPizza.name)
/*
Preparing Ny style Sauce and Cheese Pizza
Tossing dough...
Adding sauce
Adding toppings [&amp;quot;Grated Reggiano Cheese&amp;quot;]
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in the official PizzaStore box
*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Посетим пиццерию в Чикаго и аналогично закажем сырную пиццу&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;let chikagoStore = ChikagoPizzaStore()
let ChikagoPizza = chikagoStore.orderPizza(&amp;quot;cheese&amp;quot;)
print(ChikagoPizza.name)
/*
Preparing Chikago style Deep Dish Cheese Pizza
Tossing dough...
Adding sauce
Adding toppings [&amp;quot;Shredded Mozarella Cheese&amp;quot;]
Bake for 25 minutes at 350
Cutting pizza into square slices
Place pizza in the official PizzaStore box
Ny style Sauce and Cheese Pizza
Chikago style Deep Dish Cheese Pizza
*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;реализация-паттерна-factory-method:2473779ea5617c0f0f76721eb7a89d68&#34;&gt;Реализация паттерна Factory Method:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/FactoryMethod.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-factory-method&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Design Patterns: Decorator</title>
      <link>http://rag0n.github.io/2015/12/15/swift-design-patterns-decorator/</link>
      <pubDate>Tue, 15 Dec 2015 12:31:52 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/15/swift-design-patterns-decorator/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Decorator применяется для динамического добавления поведения или состояния объектам. Наследования не является допустимой альтернативой, т.к оно статично(этап компиляции) и применяется ко всему классу.&lt;/p&gt;

&lt;p&gt;Соответствует open/closed принципу SOLID: класс открыт для расширения, но закрыт для изменения&lt;/p&gt;

&lt;h3 id=&#34;определение&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;динамически наделяет объект новыми возможностями и является гибкой альтернативой наследованию в области расширения функциональности&lt;/li&gt;
&lt;li&gt;декорирование базового объекта путем рекурсивного завертывания(wrapping) дополнений, определяемых пользователем&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация&#34;&gt;Реализация&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Определите общий интерфейс(таким образом классы будут взаимозаменяемы)&lt;/li&gt;
&lt;li&gt;Создайте класс основного компонента(наследует общий интерфейс)&lt;/li&gt;
&lt;li&gt;Создайте базовый класс декоратора(наследует общий интерфейс)&lt;/li&gt;
&lt;li&gt;У декоратора с помощью композиции объявите переменную типа общего интерфейса&lt;/li&gt;
&lt;li&gt;Инициализируйте этот объект в инициализаторе декоратора&lt;/li&gt;
&lt;li&gt;У декоратора делегируйте методы общего интерфейса этому объекту&lt;/li&gt;
&lt;li&gt;Создайте конкретные классы декоратора для каждого дополнения&lt;/li&gt;
&lt;li&gt;Конкретные классы декоратора делегируют поведение базовому классу декоратора + добавляют свое&lt;/li&gt;
&lt;li&gt;Клиент конфигурирует тип и порядок базового и дополнительных компонентов&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;Допустим мы владеем кафе и у нас в продаже имеются различные виды кофе:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;кофе темной обжарки&lt;/li&gt;
&lt;li&gt;кофе с шоколадом&lt;/li&gt;
&lt;li&gt;кофе со взбитыми сливками&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Можно реализовать базовый класс кофе и наследовать различные варианты и комбинации конкретный типов кофе, т.о получим такой набор классов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;базовый класс кофе&lt;/li&gt;
&lt;li&gt;кофе темной обжарки&lt;/li&gt;
&lt;li&gt;кофе темной обжарки с шоколадом&lt;/li&gt;
&lt;li&gt;кофе темной обжарки со взбитыми сливками&lt;/li&gt;
&lt;li&gt;кофе темной обжарки с шоколадом и взбитыми сливками&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Другой способ решения - применение декоратора:
инкапсулируем исходный объект в интерфейсе, наследуем полученный интерфейс и основным объектом, и декоратором. При этом добавляем с помощью композиции переменную с типом интерфейса декоратору и переопределяем методы на использование делегирования. Создаем конкретные дополнения, делегируем базовому декоратору и добавляем конкретное поведение.&lt;/p&gt;

&lt;p&gt;Определяем общий интерфейс&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактный компонент, общий интерфейс
protocol Beverage {
    func cost() -&amp;gt; Double
    func description() -&amp;gt; String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создаем классы основных компонентов&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретный компонент
class Espresso: Beverage {
    func description() -&amp;gt; String {
        return &amp;quot;Espresso&amp;quot;
    }
    
    func cost() -&amp;gt; Double {
        return 1.99
    }
}

// конкретный компонент
class DarkRoast: Beverage {
    func description() -&amp;gt; String {
        return &amp;quot;Dark Roast&amp;quot;
    }
    
    func cost() -&amp;gt; Double {
        return 2.99
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создаем базовый класс декоратора, с помощью композиции объявляем переменную типа общего интерфейса, инициализируем переменную в инициализаторе и делегируем методы общего интерфейса(пункты 3, 4, 5, 6)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактный декоратор
class CondimentDecorator: Beverage {
    private var decoratedBeverage: Beverage
    
    init(beverage: Beverage) {
        decoratedBeverage = beverage
    }
    
    func description() -&amp;gt; String {
        return decoratedBeverage.description()
    }
    
    func cost() -&amp;gt; Double {
        return decoratedBeverage.cost()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создаем конкретные классы декоратора, делегируем поведение базовому декоратору и добавляем свое(пункты 7, 8)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретное дополнение
class Mocha: CondimentDecorator {
    override func description() -&amp;gt; String {
        return super.description() + &amp;quot;, Mocha&amp;quot;
    }
    
    override func cost() -&amp;gt; Double {
        return super.cost() + 0.5
    }
}

// конкретное дополнение
class Whip: CondimentDecorator {
    override func description() -&amp;gt; String {
        return super.description() + &amp;quot;, Whip&amp;quot;
    }
    
    override func cost() -&amp;gt; Double {
        return super.cost() + 0.2
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Конфигурируем нужный объект, комбинируя основной компонент и дополнения&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;var myEspresso:Beverage = Espresso()
// Espresso 1.99

var myDarkRoast:Beverage = DarkRoast()
// Dark Roast 2.99

myDarkRoast = Mocha(beverage: myDarkRoast)
myDarkRoast = Mocha(beverage: myDarkRoast)
myDarkRoast = Whip(beverage: myDarkRoast)
// Dark Roast, Mocha, Mocha, Whip 4.19

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В качестве еще одного примера:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;базовый объект - новогодняя елка&lt;/li&gt;
&lt;li&gt;класс декоратора - украшения&lt;/li&gt;
&lt;li&gt;конкретные классы декоратора - игрушки, гирлянда и тд&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;реализация-паттерна-decorator&#34;&gt;Реализация паттерна Decorator:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/Decorator.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-decorator&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Design Patterns: Observer</title>
      <link>http://rag0n.github.io/2015/12/04/swift-design-patterns-observer/</link>
      <pubDate>Fri, 04 Dec 2015 13:07:09 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/04/swift-design-patterns-observer/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Observer часто применяется для определения бизнес-логики(data model) в субъекте и делегирования view функций различным несвязанным наблюдателям. Т.е применяется во &amp;laquo;View&amp;raquo; части паттерна MVC.&lt;/p&gt;

&lt;p&gt;Существует две реализации:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pull(получение) изменений наблюдателем через геттер-методы&lt;/li&gt;
&lt;li&gt;pushing - активная доставка от субьекта&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Соответствует Dependency Inversion принципу SOLID: субьект зависит не от наблюдателей, а от интерфейса Observer. Т.о наблюдателями могут быть любые объекты, реализующие данный интерфейс. В результате получаем слабую связанность(low coupling) между объектами.&lt;/p&gt;

&lt;h3 id=&#34;определение&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;определяет отношение один-ко-многим таким образом, что при изменении состояния одного объекта происходит оповещение и обновление всех остальных зависимых объектов&lt;/li&gt;
&lt;li&gt;инкапсулирует основные(независимые) компоненты в абстракции Subject и изменяющиеся(опциональные) компоненты в Observers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация&#34;&gt;Реализация&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Разграничьте независимую(базовую, core) функциональность и зависимую(или опциональную) функциональность&lt;/li&gt;
&lt;li&gt;Смодулируйте независимую функциональность внутри subject&lt;/li&gt;
&lt;li&gt;Смодулируйте зависимую функциональность внутри observers(наблюдателей)&lt;/li&gt;
&lt;li&gt;Свяжите subject с интерфейсом observer&lt;/li&gt;
&lt;li&gt;Наблюдатели регистрирует себя самостоятельно&lt;/li&gt;
&lt;li&gt;Субъект пересылает сообщение об изменении состояния всем наблюдателям&lt;/li&gt;
&lt;li&gt;Субьект может выполнить активную доставку или наблюдатели могут сами получать необходимую информацию&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;В качестве примера: допустим у нас есть метеостанция, которая вызывает метод measurementsChanged у класса WeatherData при изменении температуры/влажности/давления.&lt;/p&gt;

&lt;p&gt;Определяем независимую функциональность внутри subject:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class WeatherData: Subject {
    private var temperature: Double!
    private var humidity: Double!
    private var pressure: Double!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Определяем зависимую функциональность внутри наблюдателей:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class CurrentConditionsDisplay: Observer, DisplayElement {
    private var temperature: Double!
    private var pressure: Double!
    
    // зависимая функциональность в данном случае это
    // представление температуры и давления в UI
    func display() {
        print(&amp;quot;Temperature = \(temperature), pressure = \(pressure)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Свяжем subject с observers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class WeatherData: Subject {
    private var observers = [Observer]()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Метеостанция посылает сообщения при изменении своего состояния:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class WeatherData: Subject {
    func notifyObservers() {
        for observer in observers {
            // активная доставка
            observer.update(temperature: temperature, humidity: humidity, pressure: pressure)
        }
    }
    
    // вызов этой функции происходит извне при изменении данных(состояния)
    func measurementsChanged() {
        notifyObservers()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Наблюдатель получает изменения с помощью активной доставки:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class WeatherData: Subject {
    func notifyObservers() {
        for observer in observers {
            // активная доставка
            observer.update(temperature: temperature, humidity: humidity, pressure: pressure)
        }
    }
    
    // вызов этой функции происходит извне при изменении данных(состояния)
    func measurementsChanged() {
        notifyObservers()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Зарегистрируем CurrentConditionsDisplay в качестве наблюдателя за метеостанцией:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class CurrentConditionsDisplay: Observer, DisplayElement {
    // humidity нас не интересует, но доставка активная - принимаем все параметры
    func update(temperature temperature: Double, humidity: Double, pressure: Double) {
        self.temperature = temperature
        self.pressure = pressure
        display()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данной реализации мы используем протокол DisplayElement, т.к предполагаем что у нас имеется несколько классов которые по разному представляют данные.&lt;/p&gt;

&lt;h4 id=&#34;реализация-паттерна-observer&#34;&gt;Реализация паттерна Observer:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/Observer.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-observer&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Design Patterns: Strategy</title>
      <link>http://rag0n.github.io/2015/12/01/swift-design-patterns-strategy/</link>
      <pubDate>Tue, 01 Dec 2015 17:54:00 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/01/swift-design-patterns-strategy/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен:010736ab8fdfc1cfa693a6e5a7960263&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Strategy применяется для уменьшения связанности. В двух словах: программируйте на уровне интерфейсов, а не реализаций.&lt;/p&gt;

&lt;p&gt;Соответствует open/closed принципу SOLID: изменение конкретных классов не влияет на клиента, т.к он зависит только от интерфейса.&lt;/p&gt;

&lt;h3 id=&#34;определение:010736ab8fdfc1cfa693a6e5a7960263&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;определяет семейство алгоритмов(поведений), инкапсулирует и обеспечивает их взаимозаменяемость. Позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.&lt;/li&gt;
&lt;li&gt;инкапсулируем абстракцию в интерфейсе, скрываем реализацию в конкретных классах&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация:010736ab8fdfc1cfa693a6e5a7960263&#34;&gt;Реализация&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Найдите алгоритм(поведение)&lt;/li&gt;
&lt;li&gt;Определите сигнатуру в супертипе(интерфейсе/абстрактном классе/протоколе)&lt;/li&gt;
&lt;li&gt;Скройте реализацию(или реализации) в конкретном классе, который соответствует этому интерфейсу&lt;/li&gt;
&lt;li&gt;Свяжите клиента алгоритма с интерфейсом&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример:010736ab8fdfc1cfa693a6e5a7960263&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;Допустим у нас есть утки. Утки могут крякать по разному: кряканье, писк, а могут и вовсе не крякать. Алгоритмом в данном случае будет способ кряканья.&lt;/p&gt;

&lt;p&gt;Теперь определим сигнатуру:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// в качестве супертипа - протокол(интерфейс)
protocol QuackBehavior {
    func quack()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Скроем реализацию в конкретных классах:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретные классы поведения, описываемые супертипом
class Quack: QuackBehavior {
    func quack() {
        print(&amp;quot;Я крякаю: quack-quack&amp;quot;)
    }
}

class QuackMute: QuackBehavior {
    func quack() {
        print(&amp;quot;Я не крякаю :(&amp;quot;)
    }
}

class Squeak: QuackBehavior {
    func quack() {
        print(&amp;quot;Я пищу: squeak-squeak&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Свяжем клиента(в нашем случае - утку) с интерфейсом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class Duck {
    // Клиент Duck связан с абстракцией, а не с конкретными реализациями
    private var quackBehavior: QuackBehavior
    
    required convenience init() {
        self.init(quackBehavior: QuackMute())
    }
    
    private init(quackBehavior: QuackBehavior) {
        self.quackBehavior = quackBehavior
    }
        
    func performQuack() {
        // делегируем поведение
        quackBehavior.quack()
    }
        
    func setQuackBehavior(quackBehavior: QuackBehavior) {
        self.quackBehavior = quackBehavior
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данной реализации метод setQuackBehavior позволяет динамически изменять поведение.&lt;/p&gt;

&lt;p&gt;В качестве другого примера можно рассмотреть магазин, который осуществляет доставку разными способами: самолетом, самолетом-экспресс, морем. В данном случае алгоритм - способ доставки. Конкретные классы перечислены выше. Изменения методов доставки(например, квадрокоптером) никак не повлияют на клиента.&lt;/p&gt;

&lt;p&gt;Стоить заметить, что вместо создания конкретных классов можно применить протоколо-ориентированный подход, а точнее использование миксинов. Т.е создаем миксины(содержащие поведение), с помощью расширений протокола добавляем реализацию по умолчанию, далее конфигурируем конкретные классы с необходимым набором поведений. В результате дублирования кода не будет.&lt;/p&gt;

&lt;h4 id=&#34;подробнее-про-протоколо-ориентированный-подход:010736ab8fdfc1cfa693a6e5a7960263&#34;&gt;Подробнее про протоколо-ориентированный подход:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftbook.ru/blog/introducing-protocol-oriented-programming-in-swift-2&#34;&gt;Знакомство с протоколо-ориентированным программированием в Swift 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.raywenderlich.com/109156/introducing-protocol-oriented-programming-in-swift-2&#34;&gt;Introducing Protocol-Oriented Programming in Swift 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.tutsplus.com/tutorials/protocol-oriented-programming-in-swift-2--cms-24979&#34;&gt;Protocol-Oriented Programming in Swift 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/#fnref2&#34;&gt;Mixins over Inheritance&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;реализация-паттерна-strategy:010736ab8fdfc1cfa693a6e5a7960263&#34;&gt;Реализация паттерна Strategy:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/Strategy.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-strategy&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Лучшие практики swift (часть 1)</title>
      <link>http://rag0n.github.io/2015/10/28/%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-swift-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1/</link>
      <pubDate>Wed, 28 Oct 2015 09:34:02 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/10/28/%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-swift-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1/</guid>
      <description>

&lt;p&gt;Я начал изучать swift сразу же после анонса. За первые пару дней я прочитал The Swift Programming Language(Apple). Я писал небольшие приложения и одновременно игрался с новым языком, но никогда не чувствовал, что язык достаточно взрослый для больших проектов.&lt;/p&gt;

&lt;p&gt;Но это было до анонса swift 2.0. После анонса я стал использовать swift все больше и больше и наконец недавно начал писать большой проект для &lt;a href=&#34;http://www.theappbusiness.com/&#34;&gt;The App Business&lt;/a&gt; используя swift.&lt;/p&gt;

&lt;p&gt;Я решил поделиться своими наблюдениями - некоторые из них очевидны и общеприняты, но, надеюсь, некоторые будут новыми для большинства читателей.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;предпочитайте-let-вместо-var&#34;&gt;Предпочитайте &lt;code&gt;let&lt;/code&gt; вместо &lt;code&gt;var&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Тренируйте свой мозг и рефлексы по умолчанию использовать let. Вы можете объявить переменную как var наперед, но я рекомендую использовать var только если вам обязательно надо изменить значение переменной. Это самый очевидный пункт из моих лучших практик, но это очень важно и стоит упоминания.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Примечание от переводчика:&lt;/em&gt;&lt;/strong&gt; в xCode 7 компилятор автоматически анализирует, меняете ли вы значение у переменной, объявленной как &lt;code&gt;var&lt;/code&gt; и предлагает изменить ее на &lt;code&gt;let&lt;/code&gt; в противном случае.&lt;/p&gt;

&lt;h2 id=&#34;предпочитайте-приватный-private-контроль-доступа&#34;&gt;Предпочитайте приватный(&lt;code&gt;private&lt;/code&gt;) контроль доступа&lt;/h2&gt;

&lt;p&gt;Опять очевидный пункт, но он также стоит упоминания. Всегда лучше скрывать как можно больше реализации(что означает доступ только из того же исходного файла).&lt;/p&gt;

&lt;h2 id=&#34;предпочитайте-не-опциональные-типы&#34;&gt;Предпочитайте не опциональные типы&lt;/h2&gt;

&lt;p&gt;Опциональные типы потрясающие. Этот концепт существует и в других языках(Scala, Haskell, и др).&lt;/p&gt;

&lt;p&gt;Но несмотря на то, какими полезными они могут быть, я все же пытаюсь избегать их, если это возможно. Это приводит к более чистому коду, если вы знаете, что переменная или атрибут содержат значение, или что функция возвращает действительное(не nil) значение.&lt;/p&gt;

&lt;p&gt;Например, я предпочитаю вызывать исключения в случаях, когда  функция не может вернуть действительное(не nil) значение. Посмотрите на &lt;code&gt;NSJSONSerialization.JSONObjectWithData&lt;/code&gt;. Эта функция гарантирует, что она возвращает значение, иначе она вызывает исключение.&lt;/p&gt;

&lt;h2 id=&#34;предпочитайте-guard-let-вместо-if-let&#34;&gt;Предпочитайте &lt;code&gt;guard let&lt;/code&gt; вместо &lt;code&gt;if let&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Что вы можете сделать в &lt;code&gt;if let&lt;/code&gt; блоке? Я почти всегда использую &lt;code&gt;guard let&lt;/code&gt; и ранний возврат из функции, если что-то идет не так. Ранний возврат способствует более легкому чтению кода, т.к вы можете гарантировать корректное состояние переменных. Если вы не можете вычислить обязательное значение, используйте ранний возврат(return).&lt;/p&gt;

&lt;h2 id=&#34;не-бойтесь-вызывать-исключения&#34;&gt;Не бойтесь вызывать исключения&lt;/h2&gt;

&lt;p&gt;Вместо раннего возврата, вы можете вызвать исключение, как альтернативную точку выхода из функции. Обработка исключений в Objective-C (&lt;code&gt;@try @catch&lt;/code&gt;) всегда была доступна, хотя использовать эту возможность было не принято. В Swift обработка исключений является фундаментальной идеей и вы должны использовать это.&lt;/p&gt;

&lt;p&gt;Например, у меня была функция парсинга, которая возвращала опциональный тип, если данные не могли быть синтаксически разобраны. Это означает, что вызывающая программа должна была проверять возвращаемое значение на &lt;code&gt;nil&lt;/code&gt;. Я отрефакторил эту функцию так, чтобы она всегда возвращала действительное значение и вызывала исключение в противном случае.&lt;/p&gt;

&lt;h2 id=&#34;не-используйте-guard-для-многочисленных-проверок&#34;&gt;Не используйте &lt;code&gt;guard&lt;/code&gt; для многочисленных проверок&lt;/h2&gt;

&lt;p&gt;Рассмотрим код:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;guard let data = data,
          son = self.jsonFromData(data),
          authors = json[&amp;quot;authors&amp;quot;] else {
  throw AuthorParserError
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В нем избегаются повторные вызовы исключения &lt;code&gt;AuthorParserError&lt;/code&gt;, но по моему мнению было бы намного лучше написать так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;guard let data = data else {
  throw AuthorParserError
}
guard let son = self.jsonFromData(data) else {
  throw AuthorParserError
}
guard let authors = json[&amp;quot;authors&amp;quot;] else {
  throw AuthorParserError
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данном варианте можно протестировать каждый случай по отдельности и вы можете быть уверены, что вы проверили все случаи, иначе Xcode покажет ошибку на неразвернутых опциональных типах.&lt;/p&gt;

&lt;h2 id=&#34;всегда-вносите-зависимости-даже-если-они-предназначены-только-для-тестирования&#34;&gt;Всегда вносите зависимости, даже если они предназначены только для тестирования&lt;/h2&gt;

&lt;p&gt;В swift есть удобная возможность - необязательные аргументы функций. С одной стороны вы можете указывать как использовать функцию по умолчанию, с другой - облегчить тестирование классов,  в частности зависимости мок-объектов.&lt;/p&gt;

&lt;p&gt;Например, если ваш класс рассчитывает, что кто-либо будет обрабатывать сетевые запросы, то почему бы не передать мок-объект в инициализатор класса?&lt;/p&gt;

&lt;p&gt;Это облегчит тестирование, т.к вы можете создать мок-объект для зависимостей и протестировать функциональность одного конкретного класса(Конечно, вы также можете написать более интегрированные тесты).&lt;/p&gt;

&lt;p&gt;Например:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;public init(requestDelegate: MyClassRequestDelegate = RequestManager()) {
  self.requestDelegate = requestDelegate
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В коде выше зависимость - это на самом деле протокол, который облегчает тестирование, т.к нам достаточно создать мок-объект, который удовлетворяет этому протоколу.&lt;/p&gt;

&lt;p&gt;Некоторые программисты могут внести зависимость навсегда, вместо определения значения по умолчанию. Но мне кажется, что главная задача для этого типа зависимостей - облегчить тестирование. Если вы не пишите библиотеку, ваше приложение вероятно всегда использует одну и ту же зависимость, поэтому есть смысл определить ее как зависимость по умолчанию.&lt;/p&gt;

&lt;h2 id=&#34;всегда-используйте-псевдонимы-типа-typealias-для-завершающих-обработчиков-если-это-возможно&#34;&gt;Всегда используйте псевдонимы типа(&lt;code&gt;typealias&lt;/code&gt;) для завершающих обработчиков(если это возможно)&lt;/h2&gt;

&lt;p&gt;Несмотря на то, что синтаксис замыканий может быть &lt;a href=&#34;http://fuckingclosuresyntax.com/&#34;&gt;запутывающим&lt;/a&gt;,  синтаксис для псевдонима замыкания очевидно проще, чем эквивалентный &lt;code&gt;typedef&lt;/code&gt; в Objective-C. Поэтому всегда объявляйте псевдоним для завершающих обработчиков(конечно если они не содержат обобщенных типов).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;typealias SomethingCompletion = (result: SomeType) -&amp;gt; Void
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;используйте-перечисления-enum-для-уменьшения-неопределенности&#34;&gt;Используйте перечисления(&lt;code&gt;enum&lt;/code&gt;) для уменьшения неопределенности&lt;/h2&gt;

&lt;p&gt;В этом фрагменте кода я передаю завершающему обработчику кортеж, который повышает неопределенность.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;doSomething() { (output: NSData?, error: NSError?) in
  // need to check if we have output or error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Заметьте, что я использую &lt;code&gt;NSError&lt;/code&gt; вместо вызова исключения, т.к невозможно вызывать исключения асинхронно.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Кортеж принимает 2 опциональных значения, что также противоречит тому, о чем о писал выше(используйте не опциональные типы).&lt;/p&gt;

&lt;p&gt;Что будет, если мы не передадим ни &lt;code&gt;output&lt;/code&gt;, ни &lt;code&gt;error&lt;/code&gt;? Что если мы передадим значения вовсе?&lt;/p&gt;

&lt;p&gt;Вы должны явно передавать аргументы в обработчик и в этом вам могут помочь перечисления. Например, вы могли бы определить перечисление &lt;code&gt;Result&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;enum Result&amp;lt;U&amp;gt; {
  case .Success(output: U)
  case .Failure(error: NSError)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Теперь можно переписать обработчик ошибок так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;doSomething() { result in
  switch (result) {
  case .Success(let output):
    // use output
  case .Failure(let error):
    // handle error
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Теперь стало абсолютно ясно, что если вызов функции был успешен, мы получим действительный результат(и мы даже будем знать его тип). И наоборот, если вызов неуспешен мы получим ошибку. Результат может быть либо успешным, либо не успешным. Без неопределенности.&lt;/p&gt;

&lt;h2 id=&#34;трюк-для-обобщенного-завершающего-обработчика&#34;&gt;Трюк для обобщенного завершающего обработчика&lt;/h2&gt;

&lt;p&gt;Предположим у вас есть функция, объявленная в протоколе:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;protocol ServiceProvider {
  func provideService&amp;lt;U where U: AnyService&amp;gt;(completion: (output: U) -&amp;gt; Void)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;При объявлении класса,
Если при объявлении класса, соответствующего протоколу(т.е реализация методов протокола) вы знаете как создать экземпляр объекта типа &lt;code&gt;U whee U: AnyService&lt;/code&gt;, тогда вы можете вернуть объект соответствующего типа(&lt;code&gt;AnyService&lt;/code&gt; протокол должен предоставлять способ создания/возвращения экземпляра).&lt;/p&gt;

&lt;p&gt;В этом случае вызывающий объект определяет какой объект должен быть возвращен в замыкании.&lt;/p&gt;

&lt;p&gt;Например:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;myOtherClass.provideService { (output: RoomService) in
  // do something with the RoomService
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Реализация &lt;code&gt;provideService&lt;/code&gt; ничего не знает о классе &lt;code&gt;RoomService&lt;/code&gt;. Этот класс просто удовлетворяет протоколу &lt;code&gt;AnyService&lt;/code&gt; благодаря чему можно создать его экземпляры в замыкании.&lt;/p&gt;

&lt;p&gt;Мне особенно нравится идея, что вызывающий может получить обратно именно тот объект, который он хочет. Вызывающий объект просто говорит: &amp;laquo;В завершающем обработчике я хочу получить экземпляр &lt;code&gt;RoomService&lt;/code&gt; и реализованная функция знает, как это сделать&amp;raquo;.&lt;/p&gt;

&lt;p&gt;Это полная противоположность блокам в &lt;code&gt;Objective C&lt;/code&gt;, где мы должны были бы объявить аргумент завершающего обработчика с типом &lt;code&gt;id&lt;/code&gt; и вызывающий объект сказал бы компилятору какой тип объекта он ожидает получить назад при реализации завершающего обработчика.&lt;/p&gt;

&lt;h2 id=&#34;лучшие-практики-замыканий&#34;&gt;Лучшие практики замыканий&lt;/h2&gt;

&lt;p&gt;Я пытаюсь сохранять замыкания как можно более краткими и лаконичными.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Если замыкание возвращает &lt;code&gt;Void&lt;/code&gt;, не пишите возращаемое значение&lt;/li&gt;
&lt;li&gt;Если тип объекта может быть выведен компилятором, не указывайте его тип&lt;/li&gt;
&lt;li&gt;Если замыкание имеет только один аргумент, не помещайте его в скобки&lt;/li&gt;
&lt;li&gt;Всегда передавайте замыкание как последний аргумент&lt;/li&gt;
&lt;li&gt;Всегда используйте trail(хвостовой) синтакс для замыкания, передающихся как последний аргумент&lt;/li&gt;
&lt;li&gt;Не используйте скобки, если компилятор того не требует(например, если функция имеет один аргумент и этот аргумент - замыкание)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Все эти утверждения спорные, но сейчас я имеено так использую замыкания. Например:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;myObject.doSomething { output in
  // do something with the output
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;вместо:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;myObject.doSomething() { (output: NSData?) -&amp;gt; Void in
  // do something with the output
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;p-s&#34;&gt;P.S&lt;/h4&gt;

&lt;p&gt;Я знаю, что перевод ужасен, именно поэтому я и сделал его(несмотря на то, что в статье используется простой англиский). Но невозможно улучшить какой-либо навык, ничего не делая. The growth mindset и все такое.&lt;/p&gt;

&lt;p&gt;Ссылка на &lt;a href=&#34;http://sam.dods.co/blog/2015/09/21/some-swift-best-practices/&#34;&gt;оригинал&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Как программно добавить Autolayout constraints</title>
      <link>http://rag0n.github.io/2015/10/24/%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-autolayout-constraints/</link>
      <pubDate>Sat, 24 Oct 2015 12:42:12 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/10/24/%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-autolayout-constraints/</guid>
      <description>

&lt;h3 id=&#34;используя-классический-способ:a2c4d5e5e44325b48ff74c80ea46f4e3&#34;&gt;Используя классический способ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;override func viewDidLoad() {
    super.viewDidLoad()

    let newView = UIView()
    newView.backgroundColor = UIColor.redColor()
    newView.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(newView)

    let horizontalConstraint = NSLayoutConstraint(item: newView, attribute: NSLayoutAttribute.CenterX, relatedBy: NSLayoutRelation.Equal, toItem: view, attribute: NSLayoutAttribute.CenterX, multiplier: 1, constant: 0)
    view.addConstraint(horizontalConstraint)

    let verticalConstraint = NSLayoutConstraint(item: newView, attribute: NSLayoutAttribute.CenterY, relatedBy: NSLayoutRelation.Equal, toItem: view, attribute: NSLayoutAttribute.CenterY, multiplier: 1, constant: 0)
    view.addConstraint(verticalConstraint)

    let widthConstraint = NSLayoutConstraint(item: newView, attribute: NSLayoutAttribute.Width, relatedBy: NSLayoutRelation.Equal, toItem: nil, attribute: NSLayoutAttribute.NotAnAttribute, multiplier: 1, constant: 100)
    newView.addConstraint(widthConstraint)
    // view.addConstraint(widthConstraint) // работает аналогично

    let heightConstraint = NSLayoutConstraint(item: newView, attribute: NSLayoutAttribute.Height, relatedBy: NSLayoutRelation.Equal, toItem: nil, attribute: NSLayoutAttribute.NotAnAttribute, multiplier: 1, constant: 100)
    newView.addConstraint(heightConstraint)
    // view.addConstraint(heightConstraint) // работает аналогично
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;используя-смешанный-способ-классический-visual-format-language:a2c4d5e5e44325b48ff74c80ea46f4e3&#34;&gt;Используя смешанный способ(Классический + Visual Format Language)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;override func viewDidLoad() {
    super.viewDidLoad()

    let newView = UIView()
    newView.backgroundColor = UIColor.redColor()
    newView.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(newView)

    let horizontalConstraint = NSLayoutConstraint(item: newView, attribute: NSLayoutAttribute.CenterX, relatedBy: NSLayoutRelation.Equal, toItem: view, attribute: NSLayoutAttribute.CenterX, multiplier: 1, constant: 0)
    view.addConstraint(horizontalConstraint)

    let verticalConstraint = NSLayoutConstraint(item: newView, attribute: NSLayoutAttribute.CenterY, relatedBy: NSLayoutRelation.Equal, toItem: view, attribute: NSLayoutAttribute.CenterY, multiplier: 1, constant: 0)
    view.addConstraint(verticalConstraint)

    let views = [&amp;quot;newView&amp;quot;: newView]

    let widthConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&amp;quot;H:[newView(100)]&amp;quot;, options: NSLayoutFormatOptions(rawValue: 0), metrics: nil, views: views)
    newView.addConstraints(widthConstraints)
    // view.addConstraints(widthConstraints) // работает аналогично

    let heightConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&amp;quot;V:[newView(100)]&amp;quot;, options: NSLayoutFormatOptions(rawValue: 0), metrics: nil, views: views)
    newView.addConstraints(heightConstraints)
    // view.addConstraints(heightConstraints) // работает аналогично

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;используя-только-visual-format-language:a2c4d5e5e44325b48ff74c80ea46f4e3&#34;&gt;Используя только Visual Format Language&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;override func viewDidLoad() {
    super.viewDidLoad()

    let newView = UIView()
    newView.backgroundColor = UIColor.redColor()
    newView.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(newView)

    let views = [&amp;quot;view&amp;quot;: view, &amp;quot;newView&amp;quot;: newView]
    let horizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&amp;quot;H:[view]-(&amp;lt;=0)-[newView(100)]&amp;quot;, options: NSLayoutFormatOptions.AlignAllCenterY, metrics: nil, views: views)
    view.addConstraints(horizontalConstraints)
    let verticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&amp;quot;V:[view]-(&amp;lt;=0)-[newView(100)]&amp;quot;, options: NSLayoutFormatOptions.AlignAllCenterX, metrics: nil, views: views)
    view.addConstraints(verticalConstraints)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;используя-autoresizing-mask:a2c4d5e5e44325b48ff74c80ea46f4e3&#34;&gt;Используя Autoresizing mask&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;override func viewDidLoad() {
    super.viewDidLoad()

    let newView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: 100.0, height: 100.0))
    newView.backgroundColor = UIColor.redColor()

    newView.translatesAutoresizingMaskIntoConstraints = true

    newView.center = CGPointMake(view.bounds.midX, view.bounds.midY)
    newView.autoresizingMask = [UIViewAutoresizing.FlexibleLeftMargin, UIViewAutoresizing.FlexibleRightMargin, UIViewAutoresizing.FlexibleTopMargin, UIViewAutoresizing.FlexibleBottomMargin]

    view.addSubview(newView)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;используя-anchor-только-для-ios-9:a2c4d5e5e44325b48ff74c80ea46f4e3&#34;&gt;Используя Anchor(только для iOS 9)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;override func viewDidLoad() {
    super.viewDidLoad()

    let newView = UIView()
    newView.backgroundColor = UIColor.redColor()
    newView.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(newView)

    let horizontalConstraint = newView.centerXAnchor.constraintEqualToAnchor(view.centerXAnchor)
    let vertivalConstraint = newView.centerYAnchor.constraintEqualToAnchor(view.centerYAnchor)
    let widthConstraint = newView.widthAnchor.constraintEqualToAnchor(nil, constant: 100)
    let heightConstraint = newView.heightAnchor.constraintEqualToAnchor(nil, constant: 100)
    NSLayoutConstraint.activateConstraints([horizontalConstraint, vertivalConstraint, widthConstraint, heightConstraint])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;используя-snapkit-сторонее-по:a2c4d5e5e44325b48ff74c80ea46f4e3&#34;&gt;Используя SnapKit(сторонее ПО)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;override func viewDidLoad() {
    super.viewDidLoad()
    
    let newView = UIView()
    newView.backgroundColor = UIColor.redColor()
    view.addSubview(newView)
    
    newView.snp_makeConstraints { (make) -&amp;gt; Void in
        make.centerX.equalTo(view)
        make.centerY.equalTo(view)
        make.width.equalTo(100)
        make.height.equalTo(100)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В этом случае не требуется ни newView.translatesAutoresizingMaskIntoConstraints = false, ни активация constraints.&lt;/p&gt;

&lt;h3 id=&#34;используя-cartography-стороннее-по:a2c4d5e5e44325b48ff74c80ea46f4e3&#34;&gt;Используя Cartography(стороннее ПО)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;override func viewDidLoad() {
    super.viewDidLoad()
    
    let newView = UIView()
    newView.backgroundColor = UIColor.redColor()
    view.addSubview(newView)
    
    constrain(newView, view) { (newView, view) -&amp;gt; () in
        newView.centerX == view.centerX
        newView.centerY == view.centerY
        newView.width == 100
        newView.height == 100
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Данная библиотека использует декларативный стиль программирования, т.е она описывает каков объект, а не как его отображать.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P.S&lt;/strong&gt; Представленный код работает для swift 2.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>