<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Паттерны on Developer&#39;s adventures</title>
    <link>http://rag0n.github.io/tags/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B/</link>
    <description>Recent content in Паттерны on Developer&#39;s adventures</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <managingEditor>alexander.ragon@gmail.com (Alexander Guschin)</managingEditor>
    <webMaster>alexander.ragon@gmail.com (Alexander Guschin)</webMaster>
    <copyright>(c) 2015 Rag0n</copyright>
    <lastBuildDate>Tue, 15 Dec 2015 12:31:52 +0300</lastBuildDate>
    <atom:link href="http://rag0n.github.io/tags/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Swift Design Patterns: Decorator</title>
      <link>http://rag0n.github.io/2015/12/15/swift-design-patterns-decorator/</link>
      <pubDate>Tue, 15 Dec 2015 12:31:52 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/15/swift-design-patterns-decorator/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Decorator применяется для динамического добавления поведения или состояния объектам. Наследования не является допустимой альтернативой, т.к оно статично(этап компиляции) и применяется ко всему классу.&lt;/p&gt;

&lt;p&gt;Соответствует open/closed принципу SOLID: класс открыт для расширения, но закрыт для изменения&lt;/p&gt;

&lt;h3 id=&#34;определение&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;динамически наделяет объект новыми возможностями и является гибкой альтернативой наследованию в области расширения функциональности&lt;/li&gt;
&lt;li&gt;декорирование базового объекта путем рекурсивного завертывания(wrapping) дополнений, определяемых пользователем&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация&#34;&gt;Реализация&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Определите общий интерфейс(таким образом классы будут взаимозаменяемы)&lt;/li&gt;
&lt;li&gt;Создайте класс основного компонента(наследует общий интерфейс)&lt;/li&gt;
&lt;li&gt;Создайте базовый класс декоратора(наследует общий интерфейс)&lt;/li&gt;
&lt;li&gt;У декоратора с помощью композиции объявите переменную типа общего интерфейса&lt;/li&gt;
&lt;li&gt;Инициализируйте этот объект в инициализаторе декоратора&lt;/li&gt;
&lt;li&gt;У декоратора делегируйте методы общего интерфейса этому объекту&lt;/li&gt;
&lt;li&gt;Создайте конкретные классы декоратора для каждого дополнения&lt;/li&gt;
&lt;li&gt;Конкретные классы декоратора делегируют поведение базовому классу декоратора + добавляют свое&lt;/li&gt;
&lt;li&gt;Клиент конфигурирует тип и порядок базового и дополнительных компонентов&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;Допустим мы владеем кафе и у нас в продаже имеются различные виды кофе:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;кофе темной обжарки&lt;/li&gt;
&lt;li&gt;кофе с шоколадом&lt;/li&gt;
&lt;li&gt;кофе со взбитыми сливками&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Можно реализовать базовый класс кофе и наследовать различные варианты и комбинации конкретный типов кофе, т.о получим такой набор классов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;базовый класс кофе&lt;/li&gt;
&lt;li&gt;кофе темной обжарки&lt;/li&gt;
&lt;li&gt;кофе темной обжарки с шоколадом&lt;/li&gt;
&lt;li&gt;кофе темной обжарки со взбитыми сливками&lt;/li&gt;
&lt;li&gt;кофе темной обжарки с шоколадом и взбитыми сливками&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Другой способ решения - применение декоратора:
инкапсулируем исходный объект в интерфейсе, наследуем полученный интерфейс и основным объектом, и декоратором. При этом добавляем с помощью композиции переменную с типом интерфейса декоратору и переопределяем методы на использование делегирования. Создаем конкретные дополнения, делегируем базовому декоратору и добавляем конкретное поведение.&lt;/p&gt;

&lt;p&gt;Определяем общий интерфейс&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактный компонент, общий интерфейс
protocol Beverage {
    func cost() -&amp;gt; Double
    func description() -&amp;gt; String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создаем классы основных компонентов&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретный компонент
class Espresso: Beverage {
    func description() -&amp;gt; String {
        return &amp;quot;Espresso&amp;quot;
    }
    
    func cost() -&amp;gt; Double {
        return 1.99
    }
}

// конкретный компонент
class DarkRoast: Beverage {
    func description() -&amp;gt; String {
        return &amp;quot;Dark Roast&amp;quot;
    }
    
    func cost() -&amp;gt; Double {
        return 2.99
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создаем базовый класс декоратора, с помощью композиции объявляем переменную типа общего интерфейса, инициализируем переменную в инициализаторе и делегируем методы общего интерфейса(пункты 3, 4, 5, 6)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// абстрактный декоратор
class CondimentDecorator: Beverage {
    private var decoratedBeverage: Beverage
    
    init(beverage: Beverage) {
        decoratedBeverage = beverage
    }
    
    func description() -&amp;gt; String {
        return decoratedBeverage.description()
    }
    
    func cost() -&amp;gt; Double {
        return decoratedBeverage.cost()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создаем конкретные классы декоратора, делегируем поведение базовому декоратору и добавляем свое(пункты 7, 8)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретное дополнение
class Mocha: CondimentDecorator {
    override func description() -&amp;gt; String {
        return super.description() + &amp;quot;, Mocha&amp;quot;
    }
    
    override func cost() -&amp;gt; Double {
        return super.cost() + 0.5
    }
}

// конкретное дополнение
class Whip: CondimentDecorator {
    override func description() -&amp;gt; String {
        return super.description() + &amp;quot;, Whip&amp;quot;
    }
    
    override func cost() -&amp;gt; Double {
        return super.cost() + 0.2
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Конфигурируем нужный объект, комбинируя основной компонент и дополнения&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;var myEspresso:Beverage = Espresso()
// Espresso 1.99

var myDarkRoast:Beverage = DarkRoast()
// Dark Roast 2.99

myDarkRoast = Mocha(beverage: myDarkRoast)
myDarkRoast = Mocha(beverage: myDarkRoast)
myDarkRoast = Whip(beverage: myDarkRoast)
// Dark Roast, Mocha, Mocha, Whip 4.19

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В качестве еще одного примера:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;базовый объект - новогодняя елка&lt;/li&gt;
&lt;li&gt;класс декоратора - украшения&lt;/li&gt;
&lt;li&gt;конкретные классы декоратора - игрушки, гирлянда и тд&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;реализация-паттерна-strategy&#34;&gt;Реализация паттерна Strategy:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/Decorator.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-decorator&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Design Patterns: Observer</title>
      <link>http://rag0n.github.io/2015/12/04/swift-design-patterns-observer/</link>
      <pubDate>Fri, 04 Dec 2015 13:07:09 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/04/swift-design-patterns-observer/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Observer часто применяется для определения бизнес-логики(data model) в субъекте и делегирования view функций различным несвязанным наблюдателям. Т.е применяется во &amp;laquo;View&amp;raquo; части паттерна MVC.&lt;/p&gt;

&lt;p&gt;Существует две реализации:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pull(получение) изменений наблюдателем через геттер-методы&lt;/li&gt;
&lt;li&gt;pushing - активная доставка от субьекта&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Соответствует Dependency Inversion принципу SOLID: субьект зависит не от наблюдателей, а от интерфейса Observer. Т.о наблюдателями могут быть любые объекты, реализующие данный интерфейс. В результате получаем слабую связанность(low coupling) между объектами.&lt;/p&gt;

&lt;h3 id=&#34;определение&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;определяет отношение один-ко-многим таким образом, что при изменении состояния одного объекта происходит оповещение и обновление всех остальных зависимых объектов&lt;/li&gt;
&lt;li&gt;инкапсулирует основные(независимые) компоненты в абстракции Subject и изменяющиеся(опциональные) компоненты в Observers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация&#34;&gt;Реализация&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Разграничьте независимую(базовую, core) функциональность и зависимую(или опциональную) функциональность&lt;/li&gt;
&lt;li&gt;Смодулируйте независимую функциональность внутри subject&lt;/li&gt;
&lt;li&gt;Смодулируйте зависимую функциональность внутри observers(наблюдателей)&lt;/li&gt;
&lt;li&gt;Свяжите subject с интерфейсом observer&lt;/li&gt;
&lt;li&gt;Наблюдатели регистрирует себя самостоятельно&lt;/li&gt;
&lt;li&gt;Субъект пересылает сообщение об изменении состояния всем наблюдателям&lt;/li&gt;
&lt;li&gt;Субьект может выполнить активную доставку или наблюдатели могут сами получать необходимую информацию&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;В качестве примера: допустим у нас есть метеостанция, которая вызывает метод measurementsChanged у класса WeatherData при изменении температуры/влажности/давления.&lt;/p&gt;

&lt;p&gt;Определяем независимую функциональность внутри subject:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class WeatherData: Subject {
    private var temperature: Double!
    private var humidity: Double!
    private var pressure: Double!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Определяем зависимую функциональность внутри наблюдателей:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class CurrentConditionsDisplay: Observer, DisplayElement {
    private var temperature: Double!
    private var pressure: Double!
    
    // зависимая функциональность в данном случае это
    // представление температуры и давления в UI
    func display() {
        print(&amp;quot;Temperature = \(temperature), pressure = \(pressure)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Свяжем subject с observers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class WeatherData: Subject {
    private var observers = [Observer]()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Метеостанция посылает сообщения при изменении своего состояния:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class WeatherData: Subject {
    func notifyObservers() {
        for observer in observers {
            // активная доставка
            observer.update(temperature: temperature, humidity: humidity, pressure: pressure)
        }
    }
    
    // вызов этой функции происходит извне при изменении данных(состояния)
    func measurementsChanged() {
        notifyObservers()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Наблюдатель получает изменения с помощью активной доставки:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class WeatherData: Subject {
    func notifyObservers() {
        for observer in observers {
            // активная доставка
            observer.update(temperature: temperature, humidity: humidity, pressure: pressure)
        }
    }
    
    // вызов этой функции происходит извне при изменении данных(состояния)
    func measurementsChanged() {
        notifyObservers()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Зарегистрируем CurrentConditionsDisplay в качестве наблюдателя за метеостанцией:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class CurrentConditionsDisplay: Observer, DisplayElement {
    // humidity нас не интересует, но доставка активная - принимаем все параметры
    func update(temperature temperature: Double, humidity: Double, pressure: Double) {
        self.temperature = temperature
        self.pressure = pressure
        display()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данной реализации мы используем протокол DisplayElement, т.к предполагаем что у нас имеется несколько классов которые по разному представляют данные.&lt;/p&gt;

&lt;h4 id=&#34;реализация-паттерна-strategy&#34;&gt;Реализация паттерна Strategy:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/Observer.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-observer&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Design Patterns: Strategy</title>
      <link>http://rag0n.github.io/2015/12/01/swift-design-patterns-strategy/</link>
      <pubDate>Tue, 01 Dec 2015 17:54:00 +0300</pubDate>
      <author>alexander.ragon@gmail.com (Alexander Guschin)</author>
      <guid>http://rag0n.github.io/2015/12/01/swift-design-patterns-strategy/</guid>
      <description>

&lt;h3 id=&#34;зачем-нужен&#34;&gt;Зачем нужен?&lt;/h3&gt;

&lt;p&gt;Паттерн Strategy применяется для уменьшения связанности. В двух словах: программируйте на уровне интерфейсов, а не реализаций.&lt;/p&gt;

&lt;p&gt;Соответствует open/closed принципу SOLID: изменение конкретных классов не влияет на клиента, т.к он зависит только от интерфейса.&lt;/p&gt;

&lt;h3 id=&#34;определение&#34;&gt;Определение&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;определяет семейство алгоритмов(поведений), инкапсулирует и обеспечивает их взаимозаменяемость. Позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.&lt;/li&gt;
&lt;li&gt;инкапсулируем абстракцию в интерфейсе, скрываем реализацию в конкретных классах&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;реализация&#34;&gt;Реализация&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Найдите алгоритм(поведение)&lt;/li&gt;
&lt;li&gt;Определите сигнатуру в супертипе(интерфейсе/абстрактном классе/протоколе)&lt;/li&gt;
&lt;li&gt;Скройте реализацию(или реализации) в конкретном классе, который соответствует этому интерфейсу&lt;/li&gt;
&lt;li&gt;Свяжите клиента алгоритма с интерфейсом&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;пример&#34;&gt;Пример&lt;/h3&gt;

&lt;p&gt;Допустим у нас есть утки. Утки могут крякать по разному: кряканье, писк, а могут и вовсе не крякать. Алгоритмом в данном случае будет способ кряканья.&lt;/p&gt;

&lt;p&gt;Теперь определим сигнатуру:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// в качестве супертипа - протокол(интерфейс)
protocol QuackBehavior {
    func quack()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Скроем реализацию в конкретных классах:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;// конкретные классы поведения, описываемые супертипом
class Quack: QuackBehavior {
    func quack() {
        print(&amp;quot;Я крякаю: quack-quack&amp;quot;)
    }
}

class QuackMute: QuackBehavior {
    func quack() {
        print(&amp;quot;Я не крякаю :(&amp;quot;)
    }
}

class Squeak: QuackBehavior {
    func quack() {
        print(&amp;quot;Я пищу: squeak-squeak&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Свяжем клиента(в нашем случае - утку) с интерфейсом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;class Duck {
    // Клиент Duck связан с абстракцией, а не с конкретными реализациями
    private var quackBehavior: QuackBehavior
    
    required convenience init() {
        self.init(quackBehavior: QuackMute())
    }
    
    private init(quackBehavior: QuackBehavior) {
        self.quackBehavior = quackBehavior
    }
        
    func performQuack() {
        // делегируем поведение
        quackBehavior.quack()
    }
        
    func setQuackBehavior(quackBehavior: QuackBehavior) {
        self.quackBehavior = quackBehavior
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данной реализации метод setQuackBehavior позволяет динамически изменять поведение.&lt;/p&gt;

&lt;p&gt;В качестве другого примера можно рассмотреть магазин, который осуществляет доставку разными способами: самолетом, самолетом-экспресс, морем. В данном случае алгоритм - способ доставки. Конкретные классы перечислены выше. Изменения методов доставки(например, квадрокоптером) никак не повлияют на клиента.&lt;/p&gt;

&lt;p&gt;Стоить заметить, что вместо создания конкретных классов можно применить протоколо-ориентированный подход, а точнее использование миксинов. Т.е создаем миксины(содержащие поведение), с помощью расширений протокола добавляем реализацию по умолчанию, далее конфигурируем конкретные классы с необходимым набором поведений. В результате дублирования кода не будет.&lt;/p&gt;

&lt;h4 id=&#34;подробнее-про-протоколо-ориентированный-подход&#34;&gt;Подробнее про протоколо-ориентированный подход:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftbook.ru/blog/introducing-protocol-oriented-programming-in-swift-2&#34;&gt;Знакомство с протоколо-ориентированным программированием в Swift 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.raywenderlich.com/109156/introducing-protocol-oriented-programming-in-swift-2&#34;&gt;Introducing Protocol-Oriented Programming in Swift 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.tutsplus.com/tutorials/protocol-oriented-programming-in-swift-2--cms-24979&#34;&gt;Protocol-Oriented Programming in Swift 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/#fnref2&#34;&gt;Mixins over Inheritance&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;реализация-паттерна-strategy&#34;&gt;Реализация паттерна Strategy:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Rag0n/hfdp/blob/master/Strategy.playground/Contents.swift&#34;&gt;Мой playground с полной реализацией&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ochococo/Design-Patterns-In-Swift#-strategy&#34;&gt;Swift design patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>